# JAVA

[ğŸ¥ Regarder la vidÃ©o sur YouTube](https://www.youtube.com/watch?v=dQw4w9WgXcQ)

# Maven en Java

![Maven](maven.jpg)

Maven est un **outil de build** (construction de projet) qui simplifie la gestion et lâ€™automatisation du dÃ©veloppement en Java.
Maven permet de **gÃ©rer les dÃ©pendances, structurer ton projet et automatiser ton cycle de dÃ©veloppement** en Java.

---

## ğŸ”¹ Ce que fait Maven

1. **Gestion des dÃ©pendances**

   - DÃ©clare les bibliothÃ¨ques nÃ©cessaires dans un fichier unique (`pom.xml`).
   - TÃ©lÃ©charge automatiquement les JAR depuis Maven Central.

2. **Standardisation du projet**

   - Structure commune et claire :
     ```
     mon-projet/
       â”œâ”€ src/
       â”‚   â”œâ”€ main/java       (code Java)
       â”‚   â”œâ”€ main/resources  (fichiers de config)
       â”‚   â””â”€ test/java       (tests unitaires)
       â””â”€ pom.xml             (fichier de configuration Maven)
     ```

3. **Automatisation des tÃ¢ches**

   - Compilation : `mvn compile`
   - Tests : `mvn test`
   - CrÃ©ation du JAR/WAR : `mvn package`
   - Nettoyage : `mvn clean`
   - DÃ©ploiement local : `mvn install`

4. **ExtensibilitÃ©**
   - Plugins disponibles pour tests, documentation, qualitÃ© de code, etc.

---

## ğŸ”¹ Comment sâ€™y prendre (premiers pas)

### 1. Installer Maven

- TÃ©lÃ©charger [Apache Maven](https://maven.apache.org/download.cgi).
- Configurer la variable dâ€™environnement `MAVEN_HOME` et ajouter `bin` dans ton `PATH`.
- VÃ©rifier lâ€™installation :
  ```bash
  mvn -v
  ```

### 2. CrÃ©er un projet Maven

```bash
mvn archetype:generate   -DgroupId=com.example   -DartifactId=mon-projet   -DarchetypeArtifactId=maven-archetype-quickstart   -DinteractiveMode=false
```

### 3. Exemple de `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>mon-projet</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>

  <dependencies>
    <!-- DÃ©pendance JUnit pour les tests -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.13.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

</project>
```

---

## ğŸ”¹ Exemple concret

### Classe Java

Fichier : `src/main/java/com/example/App.java`

```java
package com.example;

public class App {
    public String sayHello() {
        return "Hello, Maven!";
    }

    public static void main(String[] args) {
        App app = new App();
        System.out.println(app.sayHello());
    }
}
```

# RÃ©aliser un test unitaire Java avec JUnit 5

## âš™ï¸ PrÃ©-requis

1. **Ajouter la dÃ©pendance JUnit 5** :

- Avec **Maven** (`pom.xml`) :

```xml
<dependencies>
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.2</version>
    <scope>test</scope>
  </dependency>
</dependencies>
```

- Avec **Gradle** :

```gradle
testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
```

2. VÃ©rifier que ton IDE (IntelliJ, Eclipse, VS Code) sait exÃ©cuter des tests JUnit.

---

## ğŸ§ª Exemple simple

### Classe Ã  tester

```java
public class Calculatrice {
    public int addition(int a, int b) {
        return a + b;
    }

    public int division(int a, int b) {
        if (b == 0) throw new IllegalArgumentException("Division par zÃ©ro !");
        return a / b;
    }
}
```

### Classe de test (JUnit 5)

```java
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

class CalculatriceTest {

    private Calculatrice calc;

    @BeforeEach
    void setUp() {
        calc = new Calculatrice();
    }

    @Test
    void testAddition() {
        int resultat = calc.addition(2, 3);
        assertEquals(5, resultat, "2 + 3 doit Ãªtre Ã©gal Ã  5");
    }

    @Test
    void testDivision() {
        int resultat = calc.division(10, 2);
        assertEquals(5, resultat);
    }

    @Test
    void testDivisionParZero() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            calc.division(10, 0);
        });
        assertEquals("Division par zÃ©ro !", exception.getMessage());
    }
}
```

---

## ğŸš€ Explications

- `@BeforeEach` â†’ exÃ©cutÃ© avant chaque test (instancie `Calculatrice` neuve).
- `@Test` â†’ indique quâ€™une mÃ©thode est un test.
- `assertEquals(expected, actual)` â†’ vÃ©rifie que la valeur attendue = valeur calculÃ©e.
- `assertThrows` â†’ vÃ©rifie quâ€™une exception spÃ©cifique est bien levÃ©e.

---

# Principes FIRST pour des tests logiciels de qualitÃ©

Les principes **FIRST** rÃ©sument les qualitÃ©s attendues pour Ã©crire des tests unitaires efficaces :

## ğŸ§© FIRST

1. **Fast (Rapides)**

   - Les tests doivent sâ€™exÃ©cuter vite pour pouvoir Ãªtre lancÃ©s souvent (idÃ©alement Ã  chaque sauvegarde ou commit).
   - Des tests lents dÃ©couragent les dÃ©veloppeurs de les exÃ©cuter.

2. **Independent (IndÃ©pendants)**

   - Chaque test doit pouvoir sâ€™exÃ©cuter seul, dans nâ€™importe quel ordre.
   - Pas de dÃ©pendance entre tests ni de partage dâ€™Ã©tat cachÃ© (ex. base de donnÃ©es non rÃ©initialisÃ©e).

3. **Repeatable (RÃ©pÃ©tables)**

   - Un test doit donner le mÃªme rÃ©sultat quel que soit lâ€™environnement (machine locale, CI/CD, serveur).
   - Ã‰viter les dÃ©pendances externes non contrÃ´lÃ©es (rÃ©seau, API tierces, date/heure systÃ¨me sans mock, etc.).

4. **Self-Validating (Auto-validants)**

   - Un test doit dire clairement sâ€™il passe ou Ã©choue, sans nÃ©cessiter dâ€™inspection humaine.
   - Pas de logs Ã  analyser Ã  la main pour conclure.

5. **Timely (Opportuns)**
   - Les tests doivent Ãªtre Ã©crits **au bon moment**, idÃ©alement avant ou pendant le dÃ©veloppement de la fonctionnalitÃ© (TDD/BDD).
   - Ã‰crire les tests aprÃ¨s coup conduit souvent Ã  des tests superficiels ou incomplets.

---

## âš–ï¸ Autres principes utiles

- **LisibilitÃ© > complexitÃ©** : un test doit Ãªtre simple Ã  comprendre, presque comme une documentation exÃ©cutable.
- **Isolation** : mocker ou stubber les dÃ©pendances pour cibler une seule unitÃ© de code.
- **Nommage clair** : un bon nom de test dÃ©crit _ce qui est testÃ©_ et _le rÃ©sultat attendu_.
- **Maintenance** : des tests bien structurÃ©s (Arrange-Act-Assert) se maintiennent plus facilement.
